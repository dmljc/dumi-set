---
toc: content
---

# 渲染原理

学习浏览器渲染原理更多的是为了解决性能的问题，如果你不了解这部分的知识，你就不知道什么情况下会对性能造成损伤。

执行 JS 有一个 `JS 引擎`，那么执行渲染也有一个`渲染引擎`。同样，渲染引擎`在不同的浏览器中也不是都相同的`。比如在 `Firefox` 中叫做 `Gecko`，在 `Chrome` 和 `Safari` 中都是基于 `WebKit` 开发的。(其实渲染引擎就是浏览器的内核)

## HTML 转为 DOM 树

当我们打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些 `字符串` 的，所以在网络中传输的内容其实都是 0 和 1 这些 `字节数据`。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。

![](/images/browser/render/toString.png)

当 `字节数据` 转换为 `字符串` 以后，浏览器会先将这些字符串通过 `词法分析` 转换为 `标记（token）`，这一过程在词法分析中叫做 `标记化（tokenization）。`

![](/images/browser/render/token.png)

那么什么是 `标记` 呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，`是构成代码的最小单位`。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。

![](/images/browser/render/tokenTag.png)

当结束标记化后，这些标记会紧接着转换为 `Node`，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 `DOM 树`。

![](/images/browser/render/node.png)

以上就是浏览器从网络中接收到 HTML 文件然后一系列的转换过程。完整流程图见下图:

![](/images/browser/render/dom.png)

当然，在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件，接下来就让我们先来学习浏览器如何解析 CSS 文件。

## CSS 转为 CSSOM 树

其实转换 CSS 到 CSSOM 树的过程和上一小节的过程是极其类似的

![](/images/browser/render/cssom.png)

在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。

建议:

-   避免写过于具体的 CSS 选择器
-   保证层级扁平

## 生成渲染树

当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。

![](/images/browser/render/render.png)

渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。

当浏览器生成 `渲染树` 以后，就会根据渲染树来进行 `布局`（重排、重绘），然后调用 `GPU 绘制`，合成图层，显示在屏幕上。

## 为什么操作 DOM 慢

因为 `DOM` 是属于 `渲染引擎` 中的东西，而 JS 又是 `JS 引擎` 中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个 `线程之间的通信`，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来 `重排、重绘` 的情况，所以也就导致了性能上的问题。

> 经典面试题：插入几万个 DOM，如何实现页面不卡顿？

首先我们肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。大部分人应该可以想到通过 `requestAnimationFrame` 的方式去循环的插入 DOM，其实还有种方式去解决这个问题：`虚拟滚动`（virtualized scroller）。

![](/images/browser/render/virtualizedScroller.png)

**这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。**

## 什么情况阻塞渲染

首先渲染的前提是生成渲染树，所以 `HTML` 和 `CSS` 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且 `扁平层级，优化选择器`。

然后当浏览器在解析到 `script` 标签时，会暂停构建 `DOM`，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 `script` 标签放在 `body` 标签底部的原因。

当然在当下，并不是说 `script` 标签必须放在底部，因为你可以给 script 标签添加 `defer` 或者 `async` 属性。

当 script 标签加上 `defer` 属性以后，表示该 JS 文件会 `并行下载`，但是会放到 `HTML` 解析完成后 `顺序执行`，所以对于这种情况你可以把 script 标签放在任意位置。

对于没有任何依赖的 JS 文件可以加上 `async` 属性，**表示 JS 文件下载和解析不会阻塞渲染**。

## 重排、重绘

重排、重绘会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。

-   重排是 `布局` 或者 `几何属性` 需要改变就称为`重排`。
-   重绘是当节点需要 `更改外观` 而 `不会影响布局` 的，比如改变 color 就叫称为 `重绘`。
-   重排必定会发生重绘，重绘不一定会引发重排。
-   重排所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列重排。

以下几个动作可能会导致性能问题：

-   改变 window 大小
-   改变字体
-   添加或删除样式
-   文字改变
-   定位或者浮动
-   盒模型

## 减少重排、重绘

-   使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发重排（改变了布局）
-   不要把节点的属性值放在一个循环里当成循环里的变量

```js
for (let i = 0; i < 1000; i++) {
    // 获取 offsetTop 会导致回流，因为需要去获取正确的值
    console.log(document.querySelector('.test').style.offsetTop);
}
```

-   不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
-   动画实现的速度的选择，动画速度越快，重绘次数越多，也可以选择使用 `requestAnimationFrame`
-   CSS 选择符从右往左匹配查找，避免节点层级过多
