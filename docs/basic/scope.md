---
toc: menu
---

# 作用域和闭包

## 作用域

ES6 之前 JS 没有块级作用域。例如

```js
if (true) {
    var name = 'zhangsan';
}
console.log(name);
```

从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的 name 就被暴露出去了，因此，JS 没有块级作用域，只有全局作用域和函数作用域。

```js
var a = 100;

function fn() {
    var a = 200;
    console.log('fn', a);
}
console.log('global', a);
fn();
```

全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。

```js
// 张三写的代码中
var data = {
    a: 100;
}

// 李四写的代码中
var data = {
    x: true;
}
```

这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在(function(){....})()中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。

附：ES6 中开始加入了块级作用域，使用 let 定义变量即可，如下：...

```js
if (true) {
    let name = 'zhangsan';
}
console.log(name); // 报错，因为let定义的name是在if这个块级作用域
```

## 作用域链

首先认识一下什么叫做 自由变量 。如下代码中，console.log(a)要得到 a 变量，但是在当前的作用域中没有定义 a（可对比一下 b）。当前作用域没有定义的变量，这成为 自由变量 。自由变量如何得到 —— 向父级作用域寻找。

```js
var a = 100;

function fn() {
    var b = 200;
    console.log(a);
    console.log(b);
}
fn();
```

如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。

```js
var a = 100;

function F1() {
    var b = 200;

    function F2() {
        var c = 300;
        console.log(a);// 自由变量，顺作用域链向父作用域找
        console.log(b); // 自由变量，顺作用域链向父作用域找
        console.log(c); // 本作用域的变量
    }
    F2();
}
F1()...
```

## [闭包]

红宝书上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。

我对闭包的理解是：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。

闭包的核心：内部函数访问的外部函数的变量, 可以保存在外部函数作用域内, 而不被浏览器的垃圾回收机制回收。从而让一个变量常驻内存，避免全局变量的污染。

使用场景：函数作为返回值、函数作为参数传递

闭包的优点：

-   可以让一个变量常驻内存 (如果用的多了就成了缺点)
-   避免全局变量的污染
-   私有化变量

闭包的缺点：

-   因为闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存

```js
function A() {
    let a = 1;

    function B() {
        console.log(a);
    }
    return B;
}
```

你是否会疑惑，为什么函数 A 已经弹出调用栈了，为什么函数 B 还能引用到函数 A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。

经典面试题，循环中使用闭包解决 `var` 定义函数的问题

```js
for (var i = 1; i <= 5; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000 * i);
}
```

首先因为 `setTimeout` 是个异步函数，所有会先把循环全部执行完毕，这时候 `i` 就是 6 了，所以会输出一堆 6。

解决办法如下，第一种使用闭包 (匿名自执行函数)

```js
for (var i = 1; i <= 5; i++) {
    ((i) => {
        setTimeout(() => {
            console.log(i);
        }, i * 1000);
    })(i);
}
```

PS：我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量， 因此循环中的局部变量 `i` 和 `j` 在执行完后很快就会被释放，节省内存！关键是这种机制不会污染全局对象。

第二种就是使用 `setTimeout` 的第三个参数 （作为第一个 function 的参数传进去）

```js
for (var i = 1; i <= 5; i++) {
    setTimeout(
        (i) => {
            console.log(i);
        },
        i * 1000,
        i,
    );
}
```

第三种就是使用 `let` 定义 `i` 了 （块级作用域）

```js
for (let i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i * 1000);
}
```

## 什么是内存泄漏

不再用到的内存，没有及时释放，就叫做内存泄漏。在 js 中，详细一点说就是指我们已经无法再通过 js 代码来引用到某个对象，但垃圾回收器却认为这个对象还在被引用，因此在回收的时候不会释放它。导致了分配的这块内存永远也无法被释放出来。如果这样的情况越来越多，会导致内存不够用而系统崩溃。

## 垃圾回收机制

js 引擎为了解决内存泄漏问题，才有了垃圾回收机制，能够让 js 自动的管理内存，将内存中不在使用的变量回收掉，然后释放出内存空间。

js 用了两种策略，一个是 **标记清除法**，另一种是 **引用计数法**，其实他两的实现原理都是 **判断当前的变量是否被引用**，如果没有被引用，就说明该变量应该被回收，怎么回收就是上边说得两种策略的事情了。

## 什么是引用？

所谓的引用就是 存储在堆内存中的对象你是直接不能访问的，而是通过栈内存中存储该对象的地址访问的，该地址就保持着对该对象的引用。

## 闭包真的会造成内存泄漏吗？

网上有很多的歧义，说闭包造成了内存的泄漏。其实内存泄漏并不是闭包造成的，**根本原因是：内部函数没有及时断开对变量的引用**！

PS：老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。
但是，现代的浏览器使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。

## 常见的 JS 内存泄漏

**1、全局变量**

对未声明的变量的引用在全局对象里创建一个新的变量。在浏览器的情况下，这个全局对象是 window。换句话说：
函数 foo 内部忘记使用 var ，实际上 JS 会把 bar 挂载到全局对象上，意外创建一个全局变量。

```js
function foo(arg) {
    bar = '这是一个隐藏的全局变量';
}
```

```js
function foo(arg) {
    window.bar = '这是一个显式的全局变量';
}
```

另一个意外的全局变量可能由 this 创建

```js
function foo() {
    this.variable = '潜在的意外全局';
}

// Foo 调用自己，this 指向了全局对象（window）
// 而不是 undefined
foo();
```

**解决方法：**

在 JavaScript 文件头部加上 'use strict'，使用严格模式避免意外的全局变量，此时上例中的 this 指向 undefined。
如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。

**2、被遗忘的计时器或回调函数**

```js
var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        // 处理 node 和 someResource
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);
```

上面的例子表明，在节点 node 或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当 node 节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。

```js
var element = document.getElementById('button');
function onClick(event) {
    element.innerHTML = 'text';
}

element.addEventListener('click', onClick);
```

对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。

但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用 removeEventListener 了。

**3、脱离 DOM 的引用**

在你要重复的操作 DOM 节点的时候，存储 DOM 节点是十分有用的。但是在你需要移除 DOM 节点的时候，需要确保移除 DOM tree 和代码中储存的引用。

```js
var element = {
    image: document.getElementById('image'),
    button: document.getElementById('button'),
};

//Do some stuff

document.body.removeChild(document.getElementById('image'));
//这个时候  虽然从dom tree中移除了id为image的节点，但是还保留了一个对该节点的引用。
// 于是image仍然不能被回收。
```

当涉及到 DOM 树内部或子节点时，需要考虑额外的考虑因素。例如，你在 JavaScript 中保持对某个表格的特定单元格的引用。有一天你决定从 DOM 中移除表格但是保留了对单元格的引用。你也许会认为除了单元格其他的都会被回收。实际并不是这样的：单元格是表格的一个子节点，子节点保持了对父节点的引用。确切的说，JS 代码中对单元格的引用造成了整个表格被留在内存中了，所以在移除有被引用的节点时候要移除其子节点。

**总结：**

-   小心使用全局变量，尽量不要使用全局变量来存储大量数据，如果是暂时使用，要在使用完成之后手动指定为 null 或者重新分配
-   如果使用了定时器，在无用的时候要记得清除。如果为 DOM 节点绑定了事件监听器，在移除节点时要先注销事件监听器。
-   在移除 DOM 节点的时候要确保在代码中没有对节点的引用，这样才能完全的移除节点。在移除父节点之前要先移除子节点。

[闭包进阶](https://segmentfault.com/a/1190000002778015)
