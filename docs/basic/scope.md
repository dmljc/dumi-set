---
toc: content
order: 3
---

# 作用域和闭包

## 作用域

ES6 之前 JS 没有块级作用域。例如

```js
if (true) {
    var name = 'zhangsan';
}
console.log(name);
```

从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的 name 就被暴露出去了，因此，`JS 没有块级作用域概念`，只有`全局作用域`和`函数作用域`。

```js
var a = 100;

function fn() {
    var a = 200;
    console.log('fn', a);
}
console.log('global', a);
fn();
```

全局作用域就是最外层的作用域，若变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。

```js
// 张三写的代码中
var data = {
    a: 100;
}

// 李四写的代码中
var data = {
    x: true;
}
```

这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在(function(){....})()中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。

附：ES6 中开始加入了块级作用域，使用 let 定义变量即可，如下：...

```js
if (true) {
    let name = 'zhangsan';
}
console.log(name); // 报错，因为let定义的name是在if这个块级作用域
```

## 作用域链

首先认识一下什么叫做 `自由变量`。`当前作用域没有定义`的变量，这成为 自由变量 。自由变量如何得到 —— 向父级作用域寻找。

```js
var a = 100;

function fn() {
    var b = 200;
    console.log(a);
    console.log(b);
}
fn();
```

如果父级也没呢？再一层一层向上寻找，直到找到`全局作用域`还是没找到，就宣布放弃。这种一层一层的关系，就是 `作用域链`。

```js
var a = 100;

function F1() {
    var b = 200;

    function F2() {
        var c = 300;
        console.log(a);// 自由变量，顺作用域链向父作用域找
        console.log(b); // 自由变量，顺作用域链向父作用域找
        console.log(c); // 本作用域的变量
    }
    F2();
}
F1()...
```

## 闭包

**红宝书上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。**

我对闭包的理解是：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。

闭包的核心：内部函数访问的外部函数的变量, 可以保存在外部函数作用域内, 而不被浏览器的垃圾回收机制回收。从而让一个变量常驻内存，避免全局变量的污染。

使用场景：函数作为返回值、函数作为参数传递

闭包的优点：

-   可以让一个变量常驻内存 (如果用的多了就成了缺点)
-   避免全局变量的污染
-   私有化变量

闭包的缺点：

-   因为闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存

```js
function A() {
    let a = 1;

    function B() {
        console.log(a);
    }
    return B;
}
```

你是否会疑惑，为什么函数 A 已经弹出调用栈了，为什么函数 B 还能引用到函数 A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的 `JS 引擎`可以通过`逃逸分析`辨别出哪些变量需要存储在`堆`上，哪些需要存储在`栈`上。

经典面试题，循环中使用闭包解决 `var` 定义函数的问题

```js
for (var i = 1; i <= 5; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000 * i);
}
```

首先因为 `setTimeout` 是个异步函数，所有会先把循环全部执行完毕，这时候 `i` 就是 6 了，所以会输出一堆 6。

解决办法如下，第一种使用闭包 (匿名自执行函数)

```js
for (var i = 1; i <= 5; i++) {
    ((i) => {
        setTimeout(() => {
            console.log(i);
        }, i * 1000);
    })(i);
}
```

PS：我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量， 因此循环中的局部变量 `i` 在执行完后很快就会被释放，节省内存！关键是这种机制不会污染全局对象。

第二种就是使用 `setTimeout` 的第三个参数 （作为第一个 function 的参数传进去）

```js
for (var i = 1; i <= 5; i++) {
    setTimeout(
        (i) => {
            console.log(i);
        },
        i * 1000,
        i,
    );
}
```

第三种就是使用 `let` 定义 `i` 了 （块级作用域）

```js
for (let i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i * 1000);
}
```

## 垃圾回收机制

js 引擎为了解决内存泄漏问题，才有了垃圾回收机制，能够让 js 自动的管理内存，将内存中不在使用的变量回收掉，然后释放出内存空间。

js 用了两种策略，一个是 **标记清除法**，另一种是 **引用计数法**，其实他两的实现原理都是 **判断当前的变量是否被引用**，如果没有被引用，就说明该变量应该被回收，怎么回收就是上边说得两种策略的事情了。

## 内存泄漏

不再用到的内存，没有及时释放，就叫做内存泄漏。在 js 中，详细一点说就是指我们已经无法再通过 js 代码来引用到某个对象，但垃圾回收器却认为这个对象还在被引用，因此在回收的时候不会释放它。导致了分配的这块内存永远也无法被释放出来。如果这样的情况越来越多，会导致内存不够用而系统崩溃。

## 常见的 JS 内存泄漏

**全局变量**

`意外声明的全局变量`是最常见但也最容易修复的内存泄漏问题。下面的代码没有使用任何关键字声明 变量:

```js
function setName() {
    name = 'Jake';
}
```

此时，解释器会把变量 name 当作 window 的属性来创建(相当于 window.name = 'Jake')。 可想而知，在 window 对象上创建的属性，只要 window 本身不被清理就不会消失。这个问题很容易 解决，只要在变量声明前头加上 var、let 或 const 关键字即可，这样变量就会在函数执行完毕后 离开作用域。

**定时器**

`定时器` 也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量:

```js
let name = 'Jake';
setInterval(() => {
    console.log(name);
}, 100);
```

只要定时器一直运行，回调函数中引用的 name 就会一直占用内存。垃圾回收程序当然知道这一点，因而就不会清理外部变量。

**闭包**

使用 JavaScript `闭包`很容易在不知不觉间造成内存泄漏。请看下面的例子:

```js
let outer = function () {
    let name = 'Jake';
    return function () {
        return name;
    };
};
```

调用 outer()会导致分配给 name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回 的函数存在就不能清理 name，因为闭包一直在引用着它。假如 name 的内容很大(不止是一个小字符 串)，那可能就是个大问题了。

闭包造成了内存的泄漏的 **根本原因是：内部函数没有及时断开对变量的引用**！

PS：老的 IE 6 是无法处理`循环引用`的。因为老版本的 IE 是无法检测 `DOM` 节点与 `JavaScript` 代码之间的循环引用，会导致内存泄漏。
但是，现代的浏览器使用了更先进的垃圾回收算法（`标记清除`），已经可以正确检测和处理循环引用了。

**总结：**

-   小心使用全局变量，尽量不要用全局变量来存储大量数据，如果是暂时使用，要在使用完之后手动指定为 `null` 或者重新分配。
-   如果使用了定时器，在无用的时候要记得清除。如果为 DOM 节点绑定了事件监听器，在移除节点时要先`注销事件监听器`。
-   在移除 DOM 节点的时候要确保在代码中没有对节点的`引用`，这样才能完全的移除节点。
