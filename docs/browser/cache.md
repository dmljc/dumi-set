---
toc: content
order: 4
---

# Http 缓存

> 注意：浏览器缓存机制属于性能优化领域，并且整一章节都是一个面试题。

`缓存` 可以说是性能优化中`简单高效` 的一种优化方式了，它可以 `显著减少网络传输所带来的损耗`。

对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。

**通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。**

## 强缓存 (200)

强缓存可以通过设置两种 HTTP Header 实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200。

### Expires

```js
Expires: Wed, 22 Oct 2018 08:41:00 GMT // 过期时间点
```

`Expires` 是 HTTP/1 的产物，表示资源会在某个时间点后过期，需要再次请求。并且 **Expires 受限于本地时间**，如果修改了本地时间，可能会造成缓存失效。

### Cache-control

```js
Cache-control: max-age=30  // 30 秒后过期
```

`Cache-Control` 出现于 HTTP/1.1，**优先级高于 Expires** 。该属性值表示资源会在某个时间段之后过期，需要再次请求。

如果强缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 `HTTP Header` 实现： `Last-Modified` 和 `ETag` 。

当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 `304` 状态码，并且 **更新浏览器缓存有效期。**

## 协商缓存 (304)

### Last-Modified

`Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 `304` 状态码。

但是 `Last-Modified` 存在一些弊端：

-   如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
-   因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

因为以上这些弊端，所以在 HTTP / 1.1 出现了 `ETag` 。

### ETag

`ETag` 类似于文件指纹，`If-None-Match` 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。

如果什么缓存策略都没设置，浏览器会采用一个启发式的算法，通常会取响应头中的 `Date` 减去 `Last-Modified` 值的 10% 作为缓存时间。

对于频繁变动的资源，首先需要使用 `Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 `ETag` 或者 `Last-Modified` 来验证资源是否有效。这样的做法 **虽然不能节省请求数量，但是能显著减少响应数据大小。**

## HTTP 1.x 的问题

-   `队头阻塞`：TCP 连接上只能发送一个请求，当前的请求没有结束之前，其他的请求只能处于阻塞的状态，使得数据不能并行请求。
-   `多个TCP连接 造成 TCP慢启动`：虽然 HTTP 1.1 `管线化`可以支持请求并发，但是浏览器很难实现，chrome、firefox 等都禁用了管线化。并且 1.1 版本请求并发依赖于多个 TCP 连接，建立 TCP 连接成本很高，还会存在 `TCP慢启动`的问题。
-   `采用文本格式，头部未压缩`：HTTP 1.x 版本是采用`文本格式`，首部未压缩，而且每一个请求都会带上 `cookie`、`user-agent` 等完全相同的首部。
-   客户端需要 `主动请求`。

## HTTP 2.0

### 多路复用

HTTP 2.0 使用了 `多路复用` 技术，建立一个 TCP 连接，一个连接上面可以有任意多个流，消息分割成一个或多个帧在流里面传输。帧传输过去以后，再进行重组，形成一个完整的请求或响应。这使得所有的请求或响应都无法阻塞。

### 头部压缩

HTTP 2.0 针对头部字段，也采用了对应的压缩算法 `HPACK`，对请求头进行压缩。

### 服务器推送

HTTP 2.0 可以让服务器将响应主动“推送”到客户端缓存中。
